{
    "contents" : "# Weekend Data Course - Leaflet Course ----\n# This project is just working through this guys tutorial from his website \nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(rlang)\nlibrary(leaflet)\nlibrary(ggmap)\nlibrary(htmltools)\n# library(mapview) -- fuuuucking gdal\nlibrary(htmlwidgets)\nlibrary(shiny)\nlibrary(shinydashboard)\n\n# Intro ----\n# leaflet() function creates a map widget object - just an empty pane with no tiles or layers on it\nm <- leaflet()\n\n# you can then add tiles - the most basic one being a map tile\n# default one is from openmaps or something\nm <- leaflet() %>%\n    # note: addTiles() creates a new map object\n    addTiles() %>%\n    # can also pick where map centres by default\n    setView(lng = -149.4937, lat = 64.2008, zoom = 4)\n\n# Customising Base Maps ----\n\n# Use the addProviderTiles() fcn to choose from a bunch of map tile templates\nm <- leaflet() %>%\n    addProviderTiles(providers$Esri.NatGeoWorldMap) %>%\n    setView(lng = -149.4937, lat = 64.2008, zoom = 4)\n\nm <- leaflet() %>%\n    addProviderTiles(providers$Stamen.Watercolor) %>%\n    setView(lng = -149.4937, lat = 64.2008, zoom = 4)\n\n# note: this bit won't run because of the stupid gdal install thing\n# but example code here is still good\n\nak_counties <- readOGR(\"data/tl_2013_02_cousub/tl_2013_02_cousub.shp\")\nm <- leaflet() %>%\n    addProviderTiles(providers$Stamen.Toner) %>%\n    setView(lng = -149.4937, lat = 64.2008, zoom = 4) %>%\n    # can then add shape files and play with aesthetics of them\n    addPolygons(data = ak_counties,\n                color = \"#660000\",\n                weight = 1,              # transparency\n                smoothFactor = 0.5)      # <1: adding vertices, >1 removing vertices from polygon edges\n\n\n# Data Preparation\n# creating geometric representations of whatever data you have\n# in this case, it's FBI crime data for alaska\n# note again: this probably won't work because of the stupid gdal thing\n\nfbi_data <- readRDS(file='data/database.rds')\nfbi_tbl <- as.tibble(fbi_data)\n\n# main annoyance here is that we don't have lat/lng for this stuff\n# so we'll be using some geocode function - which is an API that has a limit for queries per day\n#### note to self - find out if a MapInfo license can get around this\n\nfbi_tbl %>%\n    filter(State == 'Alaska') %>%\n    mutate(address = paste(City, State, \"United States\")) ->\n    ak\n\naddresses <- unique(ak$address)\n\n# then we use the ggmap package - a google maps API package\ngeocodes <- geocode(addresses, source = \"google\")\n\n# but this API is weird so have to join datasets, check missing ones, then rerun to get them\naddresses_and_coords <- tibble(address = addresses,\n                               lng = geocodes$lon,\n                               lat = geocodes$lat)\n\ncounter <- 0\nwhile(sum(is.na(addresses_and_coords$lng)) > 0 && counter < 10){\n    addresses_and_coords %>%\n        filter(is.na(lng)) ->\n        missing_addresses\n    \n    addresses <- missing_addresses$address\n    geocodes <- geocode(addresses, source = \"google\")\n    \n    addresses_and_coords %>%\n        filter(is.na(lng)==FALSE) ->\n        addresses_and_coords\n    \n    new_addresses <- tibble(address = addresses,\n                            lng = geocodes$lon,\n                            lat = geocodes$lat)\n    \n    addresses_and_coords <- rbind(addresses_and_coords, new_addresses)\n    \n    counter <- counter + 1\n}\n\n# clean up environment - wouldn't be necessary if above thing was a function\nrm(geocodes, addresses, missing_addresses, new_addresses, counter)\n\n# then have to join coords to main tbl\nak <- left_join(ak, addresses_and_coords, by = 'address')\n\n# to make things less stupid, we're adding some noise to the coords - because we only have one coordindate \n# for a whole region, so the multiple data points get stacked\nak$lng <- jitter(ak$lng, factor = 1)\nak$lat <- jitter(ak$lat, factor = 1)\n\n\n# Circle Markers and Coords ----\nak %>%\n    filter(Crime.Type == 'Murder or Manslaughter') %>%\n    filter(Crime.Solved == 'No') ->\n    ak_unsolved\n\nm <- leaflet() %>%\n    addProviderTiles(providers$Stamen.Toner) %>%\n    setView(lng = -149.4937, lat = 64.2008, zoom = 4) %>%\n    # this polygons step I can't do because of the stupid gdal thing again\n#     addPolygons(data = ak_counties,\n#                 color = '#660000',\n#                 weight = 0.5,\n#                 smoothFactor = 1) %>%\n    addCircleMarkers(lng = ak_unsolved$lng, \n                     lat = ak_unsolved$lat,\n                     color = 'ffffff',\n                     weight = 1,\n                     radius = 5)\n\n# Adding Labels to Markers ----\n\n# labels need to have HTML content to be displayed\n# you can create the HTML and store it as a var to paste into for later\nak_unsolved$label <- paste(\"<p>\", ak_unsolved$City, \"</p>\",\n                           \"<p>\", ak_unsolved$Month, \" \", ak_unsolved$Year, \"</p>\",\n                           \"<p>\", ak_unsolved$Victim.Age, \"yo\", ak_unsolved$Victim.Sex, \"</p>\",\n                           \"<p>\", ak_unsolved$Victim.Race, \"</p>\",\n                           \"<p> Weapon:\", ak_unsolved$Weapon, \"</p>\")\n\nm <- leaflet() %>%\n    addProviderTiles(providers$Stamen.Toner) %>%\n    setView(lng = -149.4937, lat = 64.2008, zoom = 4) %>%\n    addCircleMarkers(lng = ak_unsolved$lng, \n                     lat = ak_unsolved$lat,\n                     color = 'ffffff',\n                     weight = 1,\n                     radius = 5,\n                     label = lapply(ak_unsolved$label, htmltools::HTML)) # needs a char vec of HTML content for the label\n\n\n# note that there are bulk other popups - but they all have similar syntax to this\n\n# Clustering Markers ----\n\nm <- leaflet() %>%\n    addProviderTiles(providers$Stamen.Toner) %>%\n    setView(lng = -149.4937, lat = 64.2008, zoom = 4) %>%\n    addCircleMarkers(lng = ak_unsolved$lng, \n                     lat = ak_unsolved$lat,\n                     color = 'ffffff',\n                     weight = 1,\n                     radius = 5,\n                     label = lapply(ak_unsolved$label, htmltools::HTML),\n                     clusterOptions = markerClusterOptions(showCoverageOnHover = FALSE) \n                     )\n\n\n# Interactive Controls ----\n# aim is to have solved and unsolved crimes, and be able to toggle between the layers\n\nak %>%\n    filter(Crime.Solved == \"Yes\") %>%\n    filter(Crime.Type == \"Murder or Manslaughter\") ->\n    ak_solved\n\nak_solved$label <- paste(\"<p>\", ak_solved$City, \"</p>\",\n                           \"<p>\", ak_solved$Month, \" \", ak_solved$Year, \"</p>\",\n                           \"<p>\", ak_solved$Victim.Age, \"yo\", ak_solved$Victim.Sex, \"</p>\",\n                           \"<p>\", ak_solved$Victim.Race, \"</p>\",\n                           \"<p> Weapon:\", ak_solved$Weapon, \"</p>\")\n\nm <- leaflet() %>%\n    addProviderTiles(providers$Stamen.Toner) %>%\n    setView(lng = -149.4937, lat = 64.2008, zoom = 4) %>%\n    addCircleMarkers(lng = ak_unsolved$lng, \n                     lat = ak_unsolved$lat,\n                     color = 'red',\n                     weight = 1,\n                     radius = 5,\n                     label = lapply(ak_unsolved$label, htmltools::HTML),\n                     # need to assign a group name to each set of markers\n                     group = 'Unsolved') %>%\n    addCircleMarkers(lng = ak_solved$lng,\n                     lat = ak_solved$lat,\n                     color = 'blue',\n                     weight = 1,\n                     radius = 5,\n                     label = lapply(ak_solved$label, htmltools::HTML),\n                     # same here, need a group to identify them\n                     group = 'Solved') %>%\n    # then you add a 'control layer' to make things interactive\n    addLayersControl(overlayGroups = c('Unsolved', 'Solved'),\n                     option = layersControlOptions(collapsed = FALSE))\n\n# can you customise the tickbox layer legend..? to show the colours for reference\n\n\n# Aligning Data with Shapefile ----\n# this section is mostly about data transforms to link values to shapefiles, and to prepare the data\n# for turning into choropleths \n\n# metric we'll be mapping to the colour aesthetic of the choropleth - solve rate over entire time horizon\n# this little processing pipeline is actually fkn sweet\nfbi_data %>%\n    mutate(solved = ifelse(Crime.Solved == \"Yes\", 1, 0)) %>% # could also use dplyr::case_when() here\n    filter(Crime.Type == \"Murder or Manslaughter\") %>%\n    group_by(State) %>%\n    summarise(Num.Murders = n(),\n              Num.Solved = sum(solved)) %>%\n    mutate(Num.Unsolved = Num.Murders - Num.Solved,\n           Solve.Rate = Num.Solved / Num.Murders) ->\n    us\n\n# we then need to map these summary stats to our shapefiles\n# whiiiiich won't work because of fucking gdal\nstates <- readOGR('data/cb_2016_us_state/cb_2016_us_state.shp')\n\nis.element(us$State, states$NAME) # returns logical(): T if value from us$State is found within states$NAME\n\n# so ^this tells us theres a spelling difference in Rhode Island - so have to correct it\nlevels(us$State)[40] <- \"Rhode Island\"  # this is shitty factor notation, which I hate\n\n\n# then have to check existence the other way\nis.element(states$NAME, us$State)\n# which shows up a bunch of missing values\n# so subset to remove them (lol)\nstates <- subset (states, is.element(states$NAME, us$State))\n# have to then reorder the rows to match the order in the shape file\n# i feel like a join makes more sense here....\nus <- us[order(match(us$State, states$NAME)),]\n\n\n\n# Creating a Choropleth ----\n# choropleth - associates a data value to a colour to a geographic area\n\n# need to bin values and create a colour mapping to them\nbins <- c(0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)\npal <- colorBin(\"RdYlBu\",\n                domain = us$Solve.Rate,\n                bins = bins) # note: pal is now a fcn\n\n\nm <- leaflet() %>%\n    setView(-96, 37.8, zoom = 4) %>%\n    addProviderTiles(providers$Stamen.Toner) %>%\n    addPolygons(data = states,\n                weight = 1,\n                smoothFactor = 0.5,\n                color = 'white',\n                fillOpacity = 0.8,\n                # this step here uses the pal() fcn created above and runs it over the solve rate vector\n                fillColor = pal(us$Solve.Rate),\n                # this then adds some highlighting and popups to make things nicer\n                highlight = highlightOptions(\n                    weight = 5,\n                    colour = '#666666',\n                    dashArray = '',     # can change to dashed lines if you want\n                    fillOpacity = 0.7,\n                    bringToFront = TRUE    # brings highlighted values to the front\n                )) \n\nlabels <- paste(\"<p>\", us$State, \"</p>\",\n                \"<p>\", \"Solve Rate: \", round(us$Solve.Rate, digits = 3), \"</p>\",\n                sep = \"\")\n\n\nm <- leaflet() %>%\n    setView(-96, 37.8, zoom = 4) %>%\n    addProviderTiles(providers$Stamen.Toner) %>%\n    addPolygons(data = states,\n                weight = 1,\n                smoothFactor = 0.5,\n                color = 'white',\n                fillOpacity = 0.8,\n                # this step here uses the pal() fcn created above and runs it over the solve rate vector\n                fillColor = pal(us$Solve.Rate),\n                # this then adds some highlighting and popups to make things nicer\n                highlight = highlightOptions(\n                    weight = 5,\n                    colour = '#666666',\n                    dashArray = '',     # can change to dashed lines if you want\n                    fillOpacity = 0.7,\n                    bringToFront = TRUE    # brings highlighted values to the front\n                ),\n                label = lapply(labels, htmltools::HTML)) %>%\n    addLegend(pal = pal,\n              values = us$Solve.Rate,\n              opacity = 0.7,\n              position = \"topright\")\n\n\n\n# Sharing Maps - Basic Exporting ----\n\n# easy dumb-boi option - Viewer Pane > Export > save as image (this gives you static output)\n# one level up - Viewer Pane > Export > save as web page (retains dynamic content, and you can still just send\n# the little html files in an email)\n\n# then you can automate exporting with the library(mapview) package - but fucking gdal fuck\n\n# can also use the saveWidget() fucntion from the library(htmlwidgets) package\n# and now this fucking doesn't work because I can't set pandoc up properly\nsaveWidget(m, file = 'dynamic_map.html')\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1521627113820.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "147107372",
    "id" : "A6A0D9C0",
    "lastKnownWriteTime" : 1521861405,
    "path" : "~/Documents/little red laptop/rscripts/wdc-leaflet/leaflet_script.R",
    "project_path" : "leaflet_script.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}